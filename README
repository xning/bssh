bssh架构大致如下：





		 	 		  ++++++++++++++
       	       	       	       	       	  +shell+ "$ " +    返回所有提示符 	       	   否
       	       	       	       	       	  +  提	++++++++ ~~~~~~~~~~~~~~~~~~~~. 	.-------------------------.
		        初始化         	  +  示	+ "# " +    	       	     ! 	|      	       	       	  |
       	       	 .----------------------> +  符	++++++++    	       	     V	V  	      	     	  |
	    	 |     	      	       	  +  存 +  -z  +    	       	    aaaaaaaa   	       	     	  |
       	       	 |     	       	       	  +  储 + 给定 +   索取所有提示符   a提判模a   shell输出是否是	  |
	    	 |     	      	       	  +  池	+字符串+ <~~~~~~~~~~~~~~~~~ a示	   a ---------------------.
	    	 |     	      	       	  ++++++++++++++    	       	    a符断块a  以提示符之一结尾？  |
	    	 |     	  .-----------------------------------------------> aaaaaaaa          	      	  |
	    	 |     	  |   	       	  	      	       	             A 	     	      	      	  |
	    	 |     	  |    	       	  	      	    	             ! 	     	      	      	  |
	    	 |     	  |    	       	       	       	      *******  输出  ! 	       	             	  |
      参数    aaaaaaa  	  |    	       	       	       	      *	 s  * ~~~~~~ . 	       	    	          |
    ~~~~~~~~> a	 驱 a  	  |   fork && exec bash && ssh        *	 h  *  	输入  	       	       	       	是|
     	      a	 动 a --->.---------------------------------> *	 e  * <----------------------------.      |        |	  |
    标准输入  a	 模 a  	       	       	       	       	      *	 l  *      	       	      	   |	  |
    ~~~~~~~~> a	 块 a <----.   	       	  	  	      *	 l  *   	    取得字符串指针 |	  |
    	      aaaaaaa  	   |   	       	  	  	      *******  	      	  .----------------.	  |
	    	 |     	   |   	       	  	  	    	       	      	  |    是否为空？   	  |
	    	 |     	   |   	       	       	       	      	      	    aaaaaaaa 	      	    	  |
	    	 |     	   |   	     是	       	              取得字符串指针a字发模a   	       	  	  |
	    	 |     	   .----------------------------------------------- a符	   a <--------------------.
	    	 |     	       	       	  ++++++++++++++++       是否为空？ a串送块a
	    	 |     	       	       	  +              +     	       	    aaaaaaaa
	    	 |     	       	       	  + 依次需要送往 +           	      A	!
	    	 |     	 初始化	       	  +              +     返回字符串指针 !	!
       	       	 .----------------------> + shell的字符串+ ~~~~~~~~~~~~~~~~~~~.	!
	    	       	 		  +	  	 +     	    	      	!
	    	       	 		  +    存储池  	 +     索取字符串指针 	!
	    	       	 		  +	  	 + <~~~~~~~~~~~~~~~~~~~~.
	    	       	 		  ++++++++++++++++

	    			   图 bssh架构

”图 bssh架构“只是对bssh工作机理的说明，并非实现说明；虽然这两者之间有很大的重合度。
比如说，上图对实现bssh至关重要的pesudo terminal就只字未提,而这一点恰恰是实现的关
键。所以这里我们主要说的是工作机理。
在上图里，使用~和!表示的路径都是数据相关的；由-和|表示的路径则是与进程执行路径有关
的。上图涉及到两个进程。为方便下文提及，我们把驱动模块所在的进程称之为控制进程，
在上图里控制进程的各个部分都用由字母a组成的方框标识；而login bash所在的进程，我们
称之为shell进程，或者更简单，sh进程，在上图里用由*组成的方框标识。shell进程是控制
进程的子进程。而且一旦我们得到了远程shell，sh进程就完全由控制进程的输入控制了。我
们主要说说控制进程相关的事情。
从上图可以看出，控制进程的执行部分有三个模块：驱动模块，提示符判断模块和字符串发送
模块。数据部分则是两个存储池。我们分别称之为提示符存储池和命令存储池。
驱动模块负责bssh的初始化和收尾清理工作。bssh由之起始，也由其终结。驱动模块首先检查
是否有"-"选项，如果有，则设定处理标准输入的标记。接着检查”-z“选项。驱动模块将每个
”-z“选项的参数放入提示符存储池里。
驱动模块初始化命令存储池时，是先考虑参数里的字符串，而后才是标准输入。注意这里我们
说是字符串而不是命令，这是因为，虽然大部分时候，字符串发送模块发送给sh进程的是各种
各样的命令，但是，有时候也会发送诸如用户名或者密码之类的东西。这一点和”-z“结合起
来，使得bssh可以处理问题的范围大大扩展。如果加上点小trick,bssh几乎可以替代expect
了。
关于bssh可以处理标准输入，要说明的是，这一点主要是基于bssh可以用在管道里的考虑，虽
然这样一来交互式的使用bssh是可以的。unix程序如果不能用在管道里，肯定不是个好程序。
所有bssh以”-“开头的参数，都必须出现在不以”-“开头参数前面。唯一例外的是参数”-“。另外
需要略微说一点的是”-l“选项，它使我们有机会事先查看我们给定的参数和命令。请参考-h选
项。
bssh可以处理ssh初次登录。可以处理su，只要-r选项给出了root密码。

如何编译?
           tar xfj bsshell.tar.bz2 && cd bsshell && make final

此程序在ubuntu 8.10、RedHat AS4和RedHat AS4上编译通过。

用法请参考-h选项。

关于配置文件
配置文件是linux下的文本文件。其基本构成部分是配置段。配置段的格式如下：
user=string
passwd=string
port=string
rootpasswd=string
server_ip1
server_ip2
......

看个简单点的配置文件：
user=ning
passwd=ningxibo
port=22
rootpasswd=123456
192.168.5.123
192.168.5.124
192.168.5.125

这个配置文件内容，指定tt2使用用户命ning和密码ningxibo通过ssh登录linux
服务器，服务器的ssh端口是22（如果是ssh默认端口22，port=22可以省略）。
登录成功后，执行su，使用root密码123456取得root权限。需要管理的服务器
是3台：192.168.5.123~125。
注意，我们这里所说的权限改变，是指ssh到服务器远程执行命令命令时才会发
生的。sftp相关的动作总是在最低权限下执行；下文也需如此理解。
我们看个复杂点的配置文件。

user=ning
passwd=ningxibo
port=22
rootpasswd=123456
192.168.5.123
192.168.5.124
192.168.5.125
user=liwei
passwd=liweiwj
port=8000
192.168.5.126
192.168.5.127
user=root
passwd=ming
port=23456
rootpasswd=
192.168.5.128
192.168.5.129
192.168.5.130

这个配置文件内容比起第一个来，复杂了一些。我们逐一说说。
对于192.168.5.123～125这3台服务器，仍然如上面解释所说的方式登录。
192.168.5.126~127这两台服务器，其root密码没有变，但是登录用的普通用户
帐号却变了liwei,这个用户的密码是liweiwj。192.168.5.128～130这三台服务器，
则是直接用root账户登录。需要注意的是，不需要su转变权限的情况下，无需
rootpasswd配置。root账户和普通账户使用相同的配置项：user=?和passwd=？。
需要注意的是192.168.5.128~130的登录过程虽然不需要配置rootpasswd，但是与之
相关的配置段里，仍然需要有个“rootpasswd＝”设置。这是因为上面其他服务器的
配置段里，有rootpasswd相关的配置。配置段总是继承其上面段里的变量定义。
所以192.168.5.128~130的配置段，要用“rootpasswd＝”明显的取消上面配置端里
rootpasswd的配置。
就是说，user、passwd、port、rootpasswd在一个配置段里的设定，会影响其下
的配置段，除非其下的配置段另有设定，否则这些变量值不变。还有一点就是，
不需要su变化执行权限的话，只需在配置文件里设定user和passwd既可，无需设
定rootpasswd。直接以root登录的话，把root看成普通用户即可。
tt2会忽略文件里的空行和所有以#开头的行。
